/**
 * Generated by the Babylon.JS Editor v4.4.0
 */

import { Scene } from "@babylonjs/core/scene";

import { PointerEventTypes, Mesh, PhysicsImpostor, Camera, Vector3, Sound } from "@babylonjs/core";

/**
 * Tells that this script has been generated by a graph.
 */
export const IsGraph: boolean = true;

/**
 * Tells wether or not the graph has been attached to at least one node or not.
 */
export let IsGraphAttached: boolean = false;

/**
 * Defines the generated class of the graph.
 */
export default class GraphClass {
	public ball: Mesh = this._scene.getMeshByName("ball") as Mesh;
	public camera: Camera = this._scene.getCameraByName("camera");
	public gunshot: Sound = this._scene.getSoundByName("sounds/gunshot.wav");
	public bounce: Sound = this._scene.getSoundByName("sounds/bounce.wav");

	/**
	 * Constructor.
	 * @param scene defines the scene where the graph is running.
	 */
	public constructor(private _scene: Scene, private _attachedObject: any) {

	}

	/**
	 * Called on the scene starts.
	 */
	public onStart(): void {

		this._scene.onPointerObservable.add((ev) => {
			if (ev.type !== PointerEventTypes.POINTERDOWN) {
				return;
			}

			const meshInstance_2 = this.ball.createInstance("ball instance");

			meshInstance_2.position = this.ball.absolutePosition;
			meshInstance_2.physicsImpostor = new PhysicsImpostor(meshInstance_2, PhysicsImpostor.SphereImpostor, {
				mass: 1,
				friction: 0.2,
				restitution: 0.2,
			});
			meshInstance_2.applyImpulse(this.camera.getDirection(new Vector3(0, 0, 30)), meshInstance_2.position);
			this.gunshot.play();

			const timeoutId_2 = setTimeout(() => {
				meshInstance_2.dispose(true, false);
				this.bounce.play();
			}, 1000);

		});

	}

	/**
	 * Called each frame.
	 */
	public onUpdate(): void {

	}

	/**
	 * Returns the reference to the current scene the graph is running.
	 */
	public getScene(): Scene {
		return this._scene;
	}

	/**
	 * Returns the reference to the object the graph is attached to.
	 */
	public getAttachedObject<T>(): T {
		return this._attachedObject;
	}
}
